require('dotenv').config();
const express = require('express');
const axios = require('axios');
const http = require('http');
const { Server } = require('socket.io');
const { PrismaClient } = require('@prisma/client');
// const ytdl = require('@distube/ytdl-core');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const prisma = new PrismaClient();
const app = express();

// Brevo Email Service Configuration
const BREVO_API_KEY = process.env.BREVO_API_KEY;
const EMAIL_FROM = process.env.EMAIL_FROM || 'noreply@connect2connect.com';

// Helper function to send email via Brevo
async function sendEmail({ to, subject, htmlContent }) {
    if (!BREVO_API_KEY) {
        console.log('‚ö†Ô∏è  Skipping email send - No Brevo API key configured');
        console.log(`üìã [DEV MODE] Email would be sent to: ${to}`);
        console.log(`üìã [DEV MODE] Subject: ${subject}`);
        return { success: false, error: 'No API key configured' };
    }

    try {
        console.log(`üìß Attempting to send email to ${to} via Brevo...`);
        const response = await axios.post(
            'https://api.brevo.com/v3/smtp/email',
            {
                sender: { email: EMAIL_FROM, name: 'Connect2Connect' },
                to: [{ email: to }],
                subject: subject,
                htmlContent: htmlContent
            },
            {
                headers: {
                    'api-key': BREVO_API_KEY,
                    'Content-Type': 'application/json'
                }
            }
        );
        console.log(`‚úÖ Email sent successfully! Message ID: ${response.data.messageId}`);
        return { success: true, messageId: response.data.messageId };
    } catch (error) {
        console.error('‚ùå Brevo email error:');
        console.error('   Status:', error.response?.status);
        console.error('   Error:', error.response?.data || error.message);
        console.error('   Recipient:', to);
        console.error('   Sender:', EMAIL_FROM);

        if (error.response?.status === 401) {
            console.error('   ‚ö†Ô∏è  AUTHENTICATION FAILED - Check your BREVO_API_KEY');
        } else if (error.response?.status === 400) {
            console.error('   ‚ö†Ô∏è  BAD REQUEST - Check EMAIL_FROM address or email content');
        }

        return { success: false, error: error.message, details: error.response?.data };
    }
}

// Verify Brevo API key on startup
if (BREVO_API_KEY) {
    console.log('‚úÖ Brevo API key configured - Emails will be sent via Brevo');
} else {
    console.log('‚ö†Ô∏è  No Brevo API key - Emails will only be logged to console');
}

// Trust proxy for Railway deployment
app.set("trust proxy", 1);

// Allowed origins for CORS
const allowedOrigins = [
    "http://localhost:3000",
    "https://c2c-kappa.vercel.app",
    "https://thorough-victory-production.up.railway.app"
];

// Manual CORS middleware (fixes OPTIONS preflight for Express 5)
app.use((req, res, next) => {
    const origin = req.headers.origin;

    if (allowedOrigins.includes(origin)) {
        res.setHeader("Access-Control-Allow-Origin", origin);
    }

    res.setHeader("Access-Control-Allow-Credentials", "true");
    res.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");

    // Important: Handle OPTIONS preflight
    if (req.method === "OPTIONS") {
        return res.sendStatus(200);
    }

    next();
});

// Standard CORS middleware (backup)
app.use(cors({
    origin: allowedOrigins,
    methods: ["GET", "POST"],
    allowedHeaders: ["Content-Type", "Authorization"],
    credentials: true
}));
app.use(express.json());

console.log('‚úÖ CORS configured for:', allowedOrigins);

// ‚úÖ USER DATA NOW STORED IN POSTGRESQL DATABASE (migrated from in-memory)

// Store email verification codes (temporary, will migrate to DB later)
const emailVerificationCodes = {};

// API Routes

// Root route for server status
app.get('/', (req, res) => {
    res.json({
        message: 'Connect to Connect Server is running!',
        status: 'active',
        availableEndpoints: [
            'POST /api/create-room',
            'POST /api/join-room',
            'GET /api/room/:roomId'
        ]
    });
});


// ========== ADMIN ENDPOINTS ==========

// Get all users (Admin endpoint)
app.get('/api/admin/users', (req, res) => {
    console.log('üë• ADMIN: Get all users');

    const userList = Object.values(users).map(user => ({
        userId: user.userId,
        name: user.name,
        email: user.email,
        dob: user.dob,
        isVerified: user.isVerified,
        createdAt: user.createdAt
    }));

    res.json({
        success: true,
        totalUsers: userList.length,
        users: userList
    });
});

// ========== YOUTUBE API ENDPOINTS ==========

// Search API
app.get('/api/search', async (req, res) => {
    console.log('üîç SEARCH API CALLED:', { query: req.query.query });
    const { query } = req.query;

    if (!query) {
        return res.status(400).json({ error: 'Query is required' });
    }

    const apiKey = process.env.YOUTUBE_API_KEY;
    if (!apiKey) {
        console.error('‚ùå SEARCH ERROR: Missing YouTube API Key');
        return res.status(500).json({ error: 'Server configuration error: Missing API Key' });
    }

    try {
        const response = await axios.get('https://www.googleapis.com/youtube/v3/search', {
            params: {
                part: 'snippet',
                q: query,
                type: 'video',
                maxResults: 50,
                key: apiKey
            }
        });

        const videos = response.data.items.map(item => ({
            videoId: item.id.videoId,
            title: item.snippet.title,
            thumbnail: item.snippet.thumbnails.medium.url,
            channel: item.snippet.channelTitle,
            description: item.snippet.description,
            publishDate: item.snippet.publishedAt
        }));

        console.log(`‚úÖ SEARCH SUCCESS: Found ${videos.length} videos`);
        res.json({ success: true, videos });
    } catch (error) {
        console.error('‚ùå SEARCH ERROR:', error.response ? error.response.data : error.message);
        res.status(500).json({ error: 'Failed to fetch videos from YouTube' });
    }
});

// Play API (Extract Stream URL) - REMOVED
// app.get('/api/play', async (req, res) => {
//     res.status(410).json({ error: 'This endpoint has been removed.' });
// });

// ========== AUTHENTICATION API ENDPOINTS ==========


// Signup API
app.post('/api/auth/signup', async (req, res) => {
    console.log('üìù SIGNUP API CALLED:', { name: req.body.name, email: req.body.email });
    const { name, email, password } = req.body;

    // Validation
    if (!name || !email || !password) {
        console.log('‚ùå SIGNUP: Missing required fields');
        return res.status(400).json({ error: 'Name, email, and password are required' });
    }

    try {
        // Check if email already exists
        const existingUser = await prisma.user.findUnique({
            where: { email }
        });

        if (existingUser) {
            console.log('‚ùå SIGNUP: Email already registered');
            return res.status(400).json({ error: 'Email already registered' });
        }

        // Generate simple userId: name + 3 random digits
        // Example: "John Doe" -> "johndoe456"
        const cleanName = name.toLowerCase().replace(/\s+/g, ''); // Remove spaces, lowercase
        const randomDigits = Math.floor(100 + Math.random() * 900); // Random 3-digit number (100-999)
        const userId = `${cleanName}${randomDigits}`;

        // Check if userId already exists (unlikely but possible)
        const existingUserId = await prisma.user.findUnique({
            where: { userId }
        });

        if (existingUserId) {
            // If by chance it exists, add extra random digits
            const extraDigits = Math.floor(10 + Math.random() * 90);
            userId = `${cleanName}${randomDigits}${extraDigits}`;
        }

        // Hash password
        const saltRounds = 10;
        const passwordHash = await bcrypt.hash(password, saltRounds);

        // Generate verification code
        const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();

        // Store verification code
        emailVerificationCodes[email] = {
            code: verificationCode,
            userId,
            expiresAt: Date.now() + 10 * 60 * 1000 // 10 minutes
        };

        // Create user in database
        const user = await prisma.user.create({
            data: {
                userId,
                name,
                email,
                passwordHash,
                isVerified: false
            }
        });

        // Send verification email via Brevo
        const emailResult = await sendEmail({
            to: email,
            subject: 'Verify Your Email - Connect2Connect',
            htmlContent: `
                <div style="font-family: 'Segoe UI', Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #0A0A0A; color: #F8F6F0;">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <h1 style="color: #F8F6F0; margin: 0;">Welcome to Connect2Connect!</h1>
                    </div>
                    
                    <div style="background: #1A1A1A; border: 2px solid #333; border-radius: 12px; padding: 30px; margin: 20px 0;">
                        <p style="color: #F8F6F0; font-size: 16px; margin-bottom: 20px;">Hi <strong>${name}</strong>,</p>
                        <p style="color: #999; margin-bottom: 25px;">Thanks for signing up! Your verification code is:</p>
                        
                        <div style="background: #4169E1; padding: 25px; text-align: center; border-radius: 8px; margin: 25px 0;">
                            <h1 style="color: #F8F6F0; letter-spacing: 8px; margin: 0; font-size: 36px; font-family: 'Courier New', monospace;">${verificationCode}</h1>
                        </div>
                        
                        <p style="color: #999; font-size: 14px; margin-top: 20px;">
                            ‚è±Ô∏è This code will expire in <strong style="color: #F8F6F0;">10 minutes</strong>.
                        </p>
                        <p style="color: #666; font-size: 13px; margin-top: 15px;">
                            If you didn't sign up for Connect2Connect, please ignore this email.
                        </p>
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #333;">
                        <p style="color: #666; font-size: 12px; margin: 0;">Watch together, anywhere üé¨</p>
                    </div>
                </div>
            `
        });

        if (emailResult.success) {
            console.log(`‚úÖ Verification email sent to ${email} via Brevo`);
        } else {
            console.error(`‚ùå Failed to send email to ${email}`);
            console.log(`üìã Verification code for ${email}: ${verificationCode}`);
        }

        // Log verification code (in production, send email)
        console.log(`‚úÖ SIGNUP SUCCESS - Verification code for ${email}: ${verificationCode}`);
        console.log(`‚úÖ User created in database: ${user.userId}`);
        console.log(`‚ö†Ô∏è  User must verify email before receiving access token`);

        // DO NOT return token until email is verified
        res.json({
            success: true,
            message: 'Account created! Please check your email for verification code.',
            requiresVerification: true,
            user: {
                userId: user.userId,
                name: user.name,
                email: user.email,
                isVerified: false
            }
        });
    } catch (error) {
        console.error('‚ùå SIGNUP ERROR:', error);
        res.status(500).json({ error: 'Server error during signup' });
    }
});

// Login API
app.post('/api/auth/login', async (req, res) => {
    console.log('üîê LOGIN API CALLED:', { email: req.body.email });
    const { email, password } = req.body;

    // Validation
    if (!email || !password) {
        console.log('‚ùå LOGIN: Missing required fields');
        return res.status(400).json({ error: 'Email and password are required' });
    }

    try {
        // Find user by email in database
        const user = await prisma.user.findUnique({
            where: { email }
        });

        if (!user) {
            console.log('‚ùå LOGIN: User not found');
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Compare password
        const isPasswordValid = await bcrypt.compare(password, user.passwordHash);

        if (!isPasswordValid) {
            console.log('‚ùå LOGIN: Invalid password');
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Check if email is verified
        if (!user.isVerified) {
            console.log('‚ö†Ô∏è LOGIN: Email not verified');
            return res.status(403).json({
                error: 'Email not verified',
                requiresVerification: true
            });
        }

        console.log('‚úÖ LOGIN SUCCESS:', { email, name: user.name });

        // Generate JWT token
        const token = jwt.sign(
            { userId: user.userId, email: user.email },
            process.env.JWT_SECRET,
            { expiresIn: '7d' }
        );

        // Return user data and token
        res.json({
            success: true,
            token,
            user: {
                userId: user.userId,
                name: user.name,
                email: user.email,
                isVerified: user.isVerified
            }
        });
    } catch (error) {
        console.error('‚ùå LOGIN ERROR:', error);
        res.status(500).json({ error: 'Server error during login' });
    }
});

// JWT Authentication Middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid or expired token' });
        }
        req.user = user;
        next();
    });
};

// Get Current User
app.get('/api/auth/me', authenticateToken, async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { userId: req.user.userId },
            select: {
                userId: true,
                name: true,
                email: true,
                avatarUrl: true,
                bio: true,
                interests: true,
                isVerified: true,
                createdAt: true
            }
        });

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.json({ success: true, user });
    } catch (error) {
        console.error('‚ùå GET USER ERROR:', error);
        res.status(500).json({ error: 'Server error' });
    }
});

// Verify Email API
app.post('/api/auth/verify-email', async (req, res) => {
    console.log('üìß VERIFY EMAIL API CALLED:', { email: req.body.email, code: req.body.code });
    const { email, code } = req.body;

    // Validation
    if (!email || !code) {
        console.log('‚ùå VERIFY EMAIL: Missing required fields');
        return res.status(400).json({ error: 'Email and code are required' });
    }

    // Check verification code
    const verification = emailVerificationCodes[email];
    if (!verification) {
        console.log('‚ùå VERIFY EMAIL: No verification code found');
        return res.status(400).json({ error: 'No verification code found for this email' });
    }

    // Check expiration
    if (Date.now() > verification.expiresAt) {
        delete emailVerificationCodes[email];
        console.log('‚ùå VERIFY EMAIL: Code expired');
        return res.status(400).json({ error: 'Verification code expired' });
    }

    // Check code match
    if (verification.code !== code) {
        console.log('‚ùå VERIFY EMAIL: Invalid code');
        return res.status(400).json({ error: 'Invalid verification code' });
    }

    // Mark user as verified
    const user = await prisma.user.findUnique({
        where: { userId: verification.userId }
    });

    if (user) {
        await prisma.user.update({
            where: { userId: verification.userId },
            data: { isVerified: true }
        });

        delete emailVerificationCodes[email];
        console.log('‚úÖ EMAIL VERIFIED:', { userId: user.userId, email });

        // Generate JWT token AFTER successful verification
        const token = jwt.sign(
            { userId: user.userId, email: user.email },
            process.env.JWT_SECRET,
            { expiresIn: '7d' }
        );

        console.log('‚úÖ JWT token issued after email verification');

        res.json({
            success: true,
            message: 'Email verified successfully',
            token,
            user: {
                userId: user.userId,
                name: user.name,
                email: user.email,
                isVerified: true
            }
        });
    } else {
        console.log('‚ùå VERIFY EMAIL: User not found');
        res.status(404).json({ error: 'User not found' });
    }
});


// Update User Profile API
app.put('/api/auth/profile', authenticateToken, async (req, res) => {
    console.log('?? UPDATE PROFILE API CALLED:', { userId: req.user.userId });
    const { bio, avatarUrl, interests, dateOfBirth } = req.body;

    try {
        const updateData = {};
        if (bio !== undefined) updateData.bio = bio;
        if (avatarUrl !== undefined) updateData.avatarUrl = avatarUrl;
        if (interests !== undefined) updateData.interests = interests;
        if (dateOfBirth !== undefined) updateData.dateOfBirth = new Date(dateOfBirth);

        const user = await prisma.user.update({
            where: { userId: req.user.userId },
            data: updateData,
            select: {
                userId: true,
                name: true,
                email: true,
                avatarUrl: true,
                bio: true,
                interests: true,
                dateOfBirth: true,
                isVerified: true
            }
        });

        console.log('? Profile updated successfully');
        res.json({ success: true, user });
    } catch (error) {
        console.error('? UPDATE PROFILE ERROR:', error);
        res.status(500).json({ error: 'Server error during profile update' });
    }
});

// Get Public Rooms API
app.get('/api/rooms/public', async (req, res) => {
    console.log('?? GET PUBLIC ROOMS API CALLED');
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 12;
    const skip = (page - 1) * limit;

    try {
        const totalRooms = await prisma.room.count({ where: { isPublic: true } });
        const rooms = await prisma.room.findMany({
            where: { isPublic: true },
            take: limit,
            skip: skip,
            orderBy: { createdAt: 'desc' },
            include: {
                host: { select: { userId: true, name: true, avatarUrl: true } },
                participants: { select: { userId: true } }
            }
        });

        const formattedRooms = rooms.map(room => ({
            roomId: room.roomId,
            name: room.name || 'Untitled Room',
            description: room.description,
            hostUserId: room.hostUserId,
            hostName: room.host.name,
            participantCount: room.participants.length,
            maxUsers: room.maxUsers,
            currentVideoUrl: room.currentVideoUrl,
            isPlaying: room.isPlaying,
            createdAt: room.createdAt
        }));

        res.json({
            success: true,
            rooms: formattedRooms,
            totalRooms,
            page,
            totalPages: Math.ceil(totalRooms / limit),
            hasMore: page < Math.ceil(totalRooms / limit)
        });
    } catch (error) {
        console.error('? GET PUBLIC ROOMS ERROR:', error);
        res.status(500).json({ error: 'Server error fetching rooms' });
    }
});
// ========== ROOM API ENDPOINTS ==========


// Create Room API
app.post('/api/create-room', async (req, res) => {
    console.log('üöÄ CREATE ROOM API CALLED:', { creatorName: req.body.creatorName, creatorEmail: req.body.creatorEmail });
    const { creatorName, creatorEmail } = req.body;

    if (!creatorName || !creatorEmail) {
        console.log('‚ùå CREATE ROOM: Missing required fields');
        return res.status(400).json({ error: 'Name and email are required' });
    }

    try {
        // Generate unique room ID
        const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();

        // Find or create user (needed for foreign key)
        let user = await prisma.user.findUnique({ where: { email: creatorEmail } });

        if (!user) {
            user = await prisma.user.create({
                data: {
                    userId: `temp_${Date.now()}`,
                    name: creatorName,
                    email: creatorEmail,
                    passwordHash: '',
                    isVerified: false
                }
            });
        }

        // Create room in database
        const room = await prisma.room.create({
            data: {
                roomId,
                hostUserId: user.userId,
                isPublic: false,
                maxUsers: 10
            }
        });

        // Also maintain in-memory for socket.io (temporary)
        rooms[roomId] = {
            users: [],
            videoState: { url: '', isPlaying: false, currentTime: 0, lastUpdated: Date.now() },
            createdBy: creatorEmail,
            createdAt: new Date().toISOString()
        };

        console.log('‚úÖ CREATE ROOM SUCCESS - DB:', room.roomId);
        res.json({ success: true, roomId, message: 'Room created successfully' });
    } catch (error) {
        console.error('‚ùå CREATE ROOM ERROR:', error);
        res.status(500).json({ error: 'Failed to create room' });
    }
});

// Send Verification Code API
app.post('/api/send-verification', (req, res) => {
    console.log('üìß SEND VERIFICATION API CALLED:', { email: req.body.email, roomId: req.body.roomId });
    const { email, roomId } = req.body;

    if (!email || !roomId) {
        console.log('‚ùå SEND VERIFICATION: Missing required fields');
        return res.status(400).json({ error: 'Email and room ID are required' });
    }

    if (!rooms[roomId]) {
        return res.status(404).json({ error: 'Room not found' });
    }

    // Generate 6-digit verification code
    const code = Math.floor(100000 + Math.random() * 900000).toString();

    // Store verification code (expires in 10 minutes)
    verificationCodes[email] = {
        code,
        roomId,
        expiresAt: Date.now() + 10 * 60 * 1000
    };

    // In production, send email here
    console.log(`Verification code for ${email}: ${code}`);

    console.log('‚úÖ VERIFICATION CODE SENT:', { email, roomId, code });
    res.json({
        success: true,
        message: 'Verification code sent to your email'
    });
});

// Verify Code API
app.post('/api/verify-code', (req, res) => {
    console.log('üîê VERIFY CODE API CALLED:', { email: req.body.email, code: req.body.code, name: req.body.name });
    const { email, code, name } = req.body;

    if (!email || !code || !name) {
        console.log('‚ùå VERIFY CODE: Missing required fields');
        return res.status(400).json({ error: 'Email, code, and name are required' });
    }

    const verification = verificationCodes[email];

    if (!verification) {
        return res.status(400).json({ error: 'No verification code found' });
    }

    if (Date.now() > verification.expiresAt) {
        delete verificationCodes[email];
        return res.status(400).json({ error: 'Verification code expired' });
    }

    if (verification.code !== code) {
        return res.status(400).json({ error: 'Invalid verification code' });
    }

    // Clean up verification code
    delete verificationCodes[email];

    console.log('‚úÖ VERIFICATION SUCCESS:', { email, name, roomId: verification.roomId });
    res.json({
        success: true,
        roomId: verification.roomId,
        message: 'Verification successful'
    });
});

// Join Room API (without verification)
app.post('/api/join-room', async (req, res) => {
    console.log('üö™ JOIN ROOM API CALLED:', { name: req.body.name, email: req.body.email, roomId: req.body.roomId });
    const { name, email, roomId } = req.body;

    if (!name || !email || !roomId) {
        console.log('‚ùå JOIN ROOM: Missing required fields');
        return res.status(400).json({ error: 'Name, email, and room ID are required' });
    }

    try {
        // Check if room exists in database
        const room = await prisma.room.findUnique({
            where: { roomId }
        });

        if (!room) {
            console.log('‚ùå JOIN ROOM: Room not found in database');
            return res.status(404).json({
                error: 'Room not found. Please check the Room ID.',
                hint: 'Make sure you\'re using the exact Room ID shared by the room creator'
            });
        }

        // Find or create user
        let user = await prisma.user.findUnique({ where: { email } });

        if (!user) {
            user = await prisma.user.create({
                data: {
                    userId: `temp_${Date.now()}`,
                    name,
                    email,
                    passwordHash: '',
                    isVerified: false
                }
            });
        }

        // Add participant to database
        await prisma.roomParticipant.upsert({
            where: {
                roomId_userId: {
                    roomId,
                    userId: user.userId
                }
            },
            update: { isActive: true },
            create: {
                roomId,
                userId: user.userId,
                isActive: true
            }
        });

        // Also maintain in-memory for socket.io (temporary)
        if (!rooms[roomId]) {
            rooms[roomId] = {
                users: [],
                videoState: { url: '', isPlaying: false, currentTime: 0, lastUpdated: Date.now() },
                createdBy: room.hostUserId,
                createdAt: room.createdAt.toISOString()
            };
        }

        console.log('‚úÖ JOIN ROOM SUCCESS - DB:', { roomId, userName: name });
        res.json({
            success: true,
            roomId,
            message: 'Successfully joined room'
        });
    } catch (error) {
        console.error('‚ùå JOIN ROOM ERROR:', error);
        res.status(500).json({ error: 'Failed to join room' });
    }
});

// Get Room Info API
app.get('/api/room/:roomId', (req, res) => {
    const { roomId } = req.params;

    if (!rooms[roomId]) {
        return res.status(404).json({ error: 'Room not found' });
    }

    res.json({
        success: true,
        room: {
            id: roomId,
            userCount: rooms[roomId].users.length,
            createdAt: rooms[roomId].createdAt
        }
    });
});

const server = http.createServer(app);

const io = new Server(server, {
    cors: {
        origin: [
            "http://localhost:3000",
            "https://c2c-kappa.vercel.app",
            "https://thorough-victory-production.up.railway.app"
        ],
        methods: ["GET", "POST"],
        credentials: true
    }
});

// Store room data (simple in-memory storage for MVP)
// Structure: { roomId: { users: [ { id, name, email } ], videoState: { url, isPlaying, currentTime, lastUpdated }, createdBy, createdAt } }
const rooms = {};

// Store user verification codes (in production, use Redis or database)
const verificationCodes = {};

io.on('connection', (socket) => {
    console.log(`User Connected: ${socket.id}`);

    // Heartbeat to keep connection alive
    const heartbeat = setInterval(() => {
        socket.emit("ping", Date.now());
    }, 5000);

    socket.on("pong", () => { });

    // Clear heartbeat on disconnect
    socket.on('disconnect', () => {
        clearInterval(heartbeat);
    });

    // Join Room Event
    socket.on('join_room', (data) => {
        const { room, name } = data;
        socket.join(room);

        // Initialize room if it doesn't exist
        if (!rooms[room]) {
            rooms[room] = {
                users: [],
                videoState: {
                    url: '',
                    isPlaying: false,
                    currentTime: 0,
                    lastUpdated: Date.now()
                },
                playlist: []
            };
        }

        // Add user to room
        const user = { id: socket.id, name };
        rooms[room].users.push(user);

        console.log(`User ${name} (${socket.id}) joined room: ${room}`);
        console.log(`Room ${room} now has ${rooms[room].users.length} users`);

        // Send current video state to the new user
        if (rooms[room].videoState.url) {
            socket.emit('receive_video_state', rooms[room].videoState);
            console.log(`Sent current video state to ${name}:`, rooms[room].videoState);
        }

        // Notify others in the room
        socket.to(room).emit('receive_message', {
            message: `${name} has joined the room`,
            username: 'System',
            time: new Date().toLocaleTimeString(),
        });

        // Send current room users to all users
        io.to(room).emit('room_users', rooms[room].users);

        // Send current playlist to new user
        if (rooms[room].playlist && rooms[room].playlist.length > 0) {
            socket.emit('receive_playlist', rooms[room].playlist);
        }
    });

    // Send Message Event
    socket.on('send_message', (data) => {
        // data: { room, message, username, time }
        socket.to(data.room).emit('receive_message', data);
    });

    // Video Sync Events
    socket.on('video_play', (data) => {
        const { room, currentTime } = data;
        if (rooms[room]) {
            rooms[room].videoState.isPlaying = true;
            rooms[room].videoState.currentTime = currentTime;
            rooms[room].videoState.lastUpdated = Date.now();
        }
        socket.to(room).emit('receive_video_play', { currentTime });
    });

    socket.on('video_pause', (data) => {
        const { room, currentTime } = data;
        if (rooms[room]) {
            rooms[room].videoState.isPlaying = false;
            rooms[room].videoState.currentTime = currentTime;
            rooms[room].videoState.lastUpdated = Date.now();
        }
        socket.to(room).emit('receive_video_pause', { currentTime });
    });

    socket.on('video_seek', (data) => {
        const { room, currentTime } = data;
        if (rooms[room]) {
            rooms[room].videoState.currentTime = currentTime;
            rooms[room].videoState.lastUpdated = Date.now();
        }
        socket.to(room).emit('receive_video_seek', { currentTime });
    });

    socket.on('video_url_change', (data) => {
        const { room, url } = data;
        if (rooms[room]) {
            rooms[room].videoState.url = url;
            rooms[room].videoState.currentTime = 0;
            rooms[room].videoState.isPlaying = false;
            rooms[room].videoState.lastUpdated = Date.now();
        }
        console.log(`Video URL changed in room ${room}:`, url);
        socket.to(room).emit('receive_video_url_change', { url });
    });

    // Playlist Events
    socket.on('add_to_playlist', (data) => {
        const { room, video } = data;
        if (rooms[room]) {
            if (!rooms[room].playlist) rooms[room].playlist = [];
            // Check for duplicates
            const exists = rooms[room].playlist.find(v => v.videoId === video.videoId);
            if (!exists) {
                rooms[room].playlist.push(video);
                io.to(room).emit('receive_playlist', rooms[room].playlist);

                // Notify chat
                io.to(room).emit('receive_message', {
                    message: `Added "${video.title}" to playlist`,
                    username: 'System',
                    time: new Date().toLocaleTimeString(),
                });
            }
        }
    });

    socket.on('remove_from_playlist', (data) => {
        const { room, videoId } = data;
        if (rooms[room] && rooms[room].playlist) {
            rooms[room].playlist = rooms[room].playlist.filter(v => v.videoId !== videoId);
            io.to(room).emit('receive_playlist', rooms[room].playlist);
        }
    });

    socket.on('play_from_playlist', (data) => {
        const { room, videoId } = data;
        if (rooms[room] && rooms[room].playlist) {
            const video = rooms[room].playlist.find(v => v.videoId === videoId);
            if (video) {
                // Remove from playlist if desired, or keep it. For now, let's keep it.
                // Actually, usually "play next" implies removing from queue, but "play specific" might not.
                // Let's implement "remove after play" logic in the client or a separate event if needed.
                // For now, just play it.

                // We'll handle the actual URL fetching in the client for now to reuse the existing logic,
                // OR we can do it here. Let's stick to client-driven playback for consistency with current architecture.
                // But wait, we need to tell everyone to play this video.
                // The client calling this will then trigger 'video_url_change'.
            }
        }
    });

    // Get current video state (for late joiners)
    socket.on('get_video_state', (data) => {
        const { room } = data;
        if (rooms[room] && rooms[room].videoState) {
            socket.emit('receive_video_state', rooms[room].videoState);
        }
    });

    // WebRTC Signaling Events (SimplePeer - legacy)
    socket.on("callUser", (data) => {
        // data: { userToCall, signalData, from, name }
        io.to(data.userToCall).emit("callUser", {
            signal: data.signalData,
            from: data.from,
            name: data.name
        });
    });

    socket.on("answerCall", (data) => {
        // data: { to, signal }
        io.to(data.to).emit("callAccepted", { signal: data.signal, from: socket.id });
    });

    socket.on("ice-candidate", (data) => {
        // data: { to, candidate }
        io.to(data.to).emit("ice-candidate", data.candidate);
    });

    // WebRTC Signaling Events (Native RTCPeerConnection)
    socket.on("webrtc_offer", ({ target, sdp }) => {
        io.to(target).emit("webrtc_offer", { from: socket.id, sdp });
    });

    socket.on("webrtc_answer", ({ target, sdp }) => {
        io.to(target).emit("webrtc_answer", { from: socket.id, sdp });
    });

    socket.on("webrtc_ice_candidate", ({ target, candidate }) => {
        io.to(target).emit("webrtc_ice_candidate", { from: socket.id, candidate });
    });

    // Screen Share Events
    socket.on("start_screen_share", ({ room }) => {
        console.log(`User ${socket.id} started screen sharing in room ${room}`);
        socket.to(room).emit("screen_share_started", { from: socket.id });
    });

    socket.on("stop_screen_share", ({ room }) => {
        console.log(`User ${socket.id} stopped screen sharing in room ${room}`);
        socket.to(room).emit("screen_share_stopped", { from: socket.id });
    });

    // Disconnect Event
    socket.on('disconnect', () => {
        console.log('User Disconnected', socket.id);
        // Cleanup logic (remove user from rooms) could go here
        for (const roomId in rooms) {
            const room = rooms[roomId];
            const userIndex = room.users.findIndex(u => u.id === socket.id);
            if (userIndex !== -1) {
                const user = room.users[userIndex];
                room.users.splice(userIndex, 1);
                io.to(roomId).emit('receive_message', {
                    message: `${user.name} has left the room`,
                    username: 'System',
                    time: new Date().toLocaleTimeString(),
                });
                io.to(roomId).emit('room_users', room.users);
                break; // Assuming user is only in one room
            }
        }
    });
});

const PORT = process.env.PORT || 3001;

server.listen(PORT, async () => {
    console.log(`SERVER RUNNING ON PORT ${PORT}`);
    console.log(`‚úÖ Database connected (PostgreSQL via Prisma)`);
});

// Graceful shutdown - Close Prisma connection
process.on('SIGTERM', async () => {
    console.log('SIGTERM signal received: closing HTTP server');
    server.close(() => {
        console.log('HTTP server closed');
    });
    await prisma.$disconnect();
    console.log('‚úÖ Database connection closed');
    process.exit(0);
});



